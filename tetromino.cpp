#ifdef __APPLE__
#include <GLUT/glut.h> // if we are on a Mac
#else
#include <GL/glut.h> // on linux
#endif

#ifdef _WIN32
#include <Windows.h>
#else
#include <unistd.h>
#endif

#include <iostream>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include "block.cpp"

struct Coordinate
{
    int row;
    int column;
};

// Tetris Block Shapes
const char shapes[] = {'I', 'J', 'L', 'O', 'S', 'Z', 'T'};
// Stores the location of landed blocks on the Tetris grid using 0 or 1
int landedBlockLocations[ROWS][COLUMNS] = {0};
// Stores pointers of Blocks that have landed.
Block blockLocations[ROWS][COLUMNS];

// Tetronmino shapes that will be chosen at random
const bool tetroShapes[28][4] =
    {
        {0, 0, 0, 0},
        {0, 1, 1, 0},
        {0, 1, 1, 0},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {2, 2, 2, 2},
        {0, 0, 0, 0},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 0, 3, 3},
        {0, 3, 3, 0},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 4, 4, 0},
        {0, 0, 4, 4},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 5, 5, 5},
        {0, 5, 0, 0},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 6, 6, 6},
        {0, 0, 0, 6},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 7, 7, 7},
        {0, 0, 7, 0},
        {0, 0, 0, 0},
};

// Tetromino class are the different shapes that can appear and be placed on the grid
// They are made up of Blocks
class Tetromino
// Tetromino is generated by choosing a random shape from the 7 selected
// check where the shape will fit in boardLocations and pass the row and column number to each new Block object - store in blocks
{
private:
    int original[4][4]; //used for rotation to store the original shape
    int type;
    int size;
    int columnDiff;
    int rowDiff;

public:
    int shape[4][4];
    Block blocks[4]; //stores tetromino's corresponding blocks, each block has their own coordinates
    // used for array initialisation of type Tetromino
    Tetromino(){};
    // create when you want to construct a tetro
    Tetromino(bool x)
    {
        create();
        spawnShape(-2, 3);
    };
    // creates the Tetromino by setting its Type and copies the shape of that specific type into the Object's shape array
    void create()
    {
        type = (rand() % 7);
        size = 4;
        for (int y = 0; y < 4; y++)
        {
            for (int x = 0; x < 4; x++)
            {
                shape[y][x] = tetroShapes[(type * 4) + y][x];
                original[y][x] = tetroShapes[(type * 4) + y][x];
            }
        }
    }
    // funciton used for debugging, shows the array contents of shape.
    void showShape()
    {
        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                std::cout << " " << shape[i][j] << " ";
            }
            std::cout << "\n";
        }
    }
    // spawns the shape in the hidden section of the Tetris grid: rows 1 and 2, and displays them
    void spawnShape(int row, int column)
    {
        int index = 0;
        columnDiff = 0;
        rowDiff = 0;
        while (index < size)
        {
            for (int i = 0; i < 4; i++)
            {
                for (int j = 0; j < 4; j++)
                {
                    if (shape[i][j] == 1)
                    {
                        // translate the shape onto the grid using "row" and "column" values
                        // they are either default of -2 and 3 for spawn points
                        // or, they are specified if a shape is rotated and needs to be respawned in a new location
                        Coordinate c;
                        c = performTranslation(row, column, i, j);
                        Block block(c.row, c.column, type);
                        blocks[index] = block;
                        index++;
                    }
                }
            }
        }
    }

    // Checks if a block of a Tetromino has a landed Tetris block on its left side
    bool checkLeft()
    {
        for (int i = 0; i < size; i++)
        {
            int row = blocks[i].getRow();
            int column = blocks[i].getColumn();
            if (column <= 0)
            {
                return false;
            }
            else
            {
                if (landedBlockLocations[row][column - 1] != 0)
                {
                    return false;
                }
            }
        }
        return true;
    }

    Coordinate performTranslation(int row, int column, int i, int j)
    {
        // if there is a block on the row and column specified, then do not rotate
        int newRow = 0;
        int newColumn = 0;

        int blockRow = row + i;

        int blockColumn = column + j;

        // columnDiff and rowDiff ensure that if the rotate block appears outside of the board,
        // it will move it onto the board by finding the distance from the outside block to the boundary
        if (blockColumn < 0 and columnDiff == 0)
        {
            columnDiff = 0 - blockColumn;
        }
        else if (blockColumn > 10 and columnDiff == 0)
        {
            columnDiff = 10 - blockColumn; //should be a neg value added to all the columns
        }

        if (blockRow < 0 and rowDiff == 0)
        {
            rowDiff = 0 - blockRow;
        }
        else if (row > 22 and rowDiff == 0)
        {
            rowDiff = 10 - blockRow; //should be a neg value added to all the columns
        }

        newRow = blockRow + rowDiff;
        newColumn = blockColumn + columnDiff;
        Coordinate coord;
        coord.row = newRow;
        coord.column = newColumn;
        return coord;
    }

    // Function to check if the rotated shape will collide or overlap with any landed blocks
    bool checkRotationCollision(int row, int column)
    {
        // loop through the shape matrix
        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                if (shape[i][j] != 0)
                {
                    Coordinate c;
                    c = performTranslation(row, column, i, j);
                    // retrieve the translated coords of the block after rotation
                    // check if it overlaps with any existing landed blocks
                    // if so, return true so that the shape can be reverted to the original
                    if (c.row >= 0)
                    {
                        if (landedBlockLocations[c.row][c.column] != 0)
                        {
                            return true;
                        }
                    }
                    else if (c.column > 9 or c.column < 0)
                    {
                        return true;
                    }
                    else if (c.row > 21)
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // function to check that a block has a landed block on the right of it, or a boundary, in order to halt movement to the right
    bool checkRight()
    {
        for (int i = 0; i < size; i++)
        {
            int row = blocks[i].getRow();
            int column = blocks[i].getColumn();
            if (column >= 9)
            {
                return false;
            }
            else
            {
                if (landedBlockLocations[row][column + 1] != 0)
                {
                    return false;
                }
            }
        }
        return true;
    }

    // function to check that a block has a landed block below it, or a boundary, in order to halt movement to downwards
    bool checkDown()
    {
        for (int i = 0; i < size; i++)
        {
            int row = blocks[i].getRow();
            if (row >= 21)
            {
                return false;
            }
        }
        return true;
    }

    // checks if the block has hit the bottom of the Tetris grid
    bool isBottom()
    {
        for (int i = 0; i < size; i++)
        {
            int column = blocks[i].getColumn();
            int row = blocks[i].getRow();
            if (row == 21)
            {
                setLanded();
                return true;
            }
            else if ((row != 21 and column != 9))
            {
                if (landedBlockLocations[row + 1][column] != 0)
                {
                    setLanded();
                    return true;
                }
            }
        }
        return false;
    }

    // if the block has hit another block below it, or has hit the boundary, then it has landed and pointers to the Blocks that
    // have landed are stored in landedBlockLocations.
    void setLanded()
    {
        //printf("Landed...\n");
        for (int i = 0; i < size; i++)
        {
            int row = blocks[i].getRow();
            int column = blocks[i].getColumn();
            landedBlockLocations[row][column] = 1;
            blockLocations[row][column] = blocks[i];
        }
    }

    // Check if there is a collision with another block from another Tetromino
    bool isCollision()
    {
        for (int i = 0; i < size; i++)
        {
            int row = blocks[i].getRow();
            int column = blocks[i].getColumn();
            // Check if there is a collision with another block below
            if (row != 21)
            {
                if (landedBlockLocations[row + 1][column] != 0)
                {
                    return true;
                }
            }
        }
        return false;
    }
    // when the LEFTKEY is pressed, the blocks making up the Tetromino will move to the left by 1 space
    void moveLeft()
    {
        if (checkLeft() == true and isCollision() == false)
        {
            for (int i = 0; i < size; i++)
            {
                // Check if a boundary is hit
                blocks[i].setRowColumn(blocks[i].getRow(), blocks[i].getColumn() - 1);
                blocks[i].display();
            }
        }
    }

    // when the RIGHTKEY is pressed, the blocks making up the Tetromino will move to the right by 1 space
    void moveRight()
    {
        if (checkRight() == true and isCollision() == false)
        {
            for (int i = 0; i < size; i++)
            {
                // Check if a boundary is hit
                blocks[i].setRowColumn(blocks[i].getRow(), blocks[i].getColumn() + 1);
                blocks[i].display();
            }
        }
    }

    // instantly moves the Tetromino to the bottom or the next availanle landing position below when SPACEBAR is pressed
    void instantFall()
    {
        // while there is no block blocking the bottom and there is no collision
        // the Tetromino will move to the bottom
        while (checkDown() == true and isCollision() == false)
        {
            // moves the blocks one space down
            for (int i = 0; i < size; i++)
            {
                // Check if a boundary is hit
                int row = blocks[i].getRow();
                int column = blocks[i].getColumn();
                blocks[i].setRowColumn(row + 1, column);
                blocks[i].display();
            }
        }
    }

    // Moves the block 1 space downward when a time delay of fallSpeed occurs
    void fall()
    {
        if (checkDown() == true and elapsedTime > 0 and isCollision() == false)
        {
            for (int i = 0; i < size; i++)
            {
                // Check if a boundary is hit
                int row = blocks[i].getRow();
                int column = blocks[i].getColumn();
                blocks[i].setRowColumn(row + 1, column);
                blocks[i].display();
            }
        }
        // this ensures that the block only moves once during each delay, as without it the block can move multiple times
        if (elapsedTime > 0)
        {
            elapsedTime--;
        }
    }

    // moves the block one space below when DOWNARROW is pressed
    void moveDownwards()
    {
        // if there is nothing blocking the Tetromino and there is no collision then move each block of the Tetromino down
        if (checkDown() == true and isCollision() == false)
        {
            for (int i = 0; i < size; i++)
            {
                // Check if a boundary is hit
                int row = blocks[i].getRow();
                int column = blocks[i].getColumn();
                blocks[i].setRowColumn(row + 1, column);
                blocks[i].display();
            }
        }
        if (elapsedTime > 0)
        {
            elapsedTime--;
        }
    }

    // rotates the shape matrix 90 degrees to the right and saves it as the new shape unless there is no space
    // for the block to be rotated
    void rotateRight()
    {
        int n = 4;
        // copy the original shape to an array so it can be used later
        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                original[i][j] = shape[i][j];
            }
        }
        for (int i = 0; i < n / 2; i++)
        {
            for (int j = i; j < n - i - 1; j++)
            {
                // Swapping elements after each iteration in Clockwise direction
                int temp = shape[i][j];
                shape[i][j] = shape[n - 1 - j][i];
                shape[n - 1 - j][i] = shape[n - 1 - i][n - 1 - j];
                shape[n - 1 - i][n - 1 - j] = shape[j][n - 1 - i];
                shape[j][n - 1 - i] = temp;
            }
        }
        // Printing matrix elements after rotation
        /*std::cout << "\nMatrix after rotating 90 degree clockwise:\n";
        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                std::cout << shape[i][j] << " ";
            }
            std::cout << "\n";
        }*/
        int diffRows = 0;
        int diffColumns = 0;
        int index = 0;
        // Calculate the translation matrix from the original shape matrix and the current block rows and columns
        // to translate the new shape onto the blockLocations matrix with the correct row and column numbers.
        while (index < size)
        {
            for (int i = 0; i < 4; i++)
            {
                for (int j = 0; j < 4; j++)
                {
                    if (original[i][j] != 0)
                    {
                        diffRows = blocks[index].getRow() - i;
                        diffColumns = blocks[index].getColumn() - i;
                        index++;
                    }
                }
            }
        }

        // check if a collision occurs with the new shape by translating it onto the
        // tetris board, and if so, revert the shape back to the original
        if (checkRotationCollision(diffRows, diffColumns))
        {
            for (int i = 0; i < 4; i++)
            {
                for (int j = 0; j < 4; j++)
                {
                    shape[i][j] = original[i][j];
                }
            }
        }
        // continue with the rotation
        else
        {
            // use the translation matrix on the indices of the shape variable to move the blocks in the correct
            // position for rotation
            spawnShape(diffRows, diffColumns);
        }
    }

    // Display function calls the Block display function to show the tetromino
    void display()
    {
        for (int i = 0; i < size; i++)
        {
            blocks[i].display();
        }
    }

    // Display for overloaded display() func of block - used for lookahead blocks
    void display(float left, float right, float bottom, float top)
    {
        for (int i = 0; i < size; i++)
        {
            blocks[i].display(left, right, bottom, top);
        }
    }
};