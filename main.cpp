#ifdef __APPLE__
#include <GLUT/glut.h> // if we are on a Mac
#else
#include <GL/glut.h> // on linux
#endif

#ifdef _WIN32
#include <Windows.h>
#else
#include <unistd.h>
#endif

#include <iostream>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

#define ROWS 22
#define VISABLE_ROWS 20
#define COLUMNS 10

const char shapes[] = {'I', 'J', 'L', 'O', 'S', 'Z', 'T'};
int boardLocations[ROWS][COLUMNS] = {0};
int landedBlockLocations[ROWS][COLUMNS] = {0};
float elapsedTime = 0.0f;

const float LEFT = 0;
const float RIGHT = 1000;
const float BOTTOM = 0;
const float TOP = 1000;

// tt = tetris
// sets up the rectangle for the tetris grid
const float tt_LEFT = 300;
const float tt_RIGHT = 600;
const float tt_BOTTOM = 100;
const float tt_TOP = 900;

struct Coordinate
{
    int row;
    int column;
};
// Tetronmino shapes that will be chosen at random
const bool tetroShapes[28][4] =
    {
        {0, 0, 0, 0},
        {0, 1, 1, 0},
        {0, 1, 1, 0},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {2, 2, 2, 2},
        {0, 0, 0, 0},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 0, 3, 3},
        {0, 3, 3, 0},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 4, 4, 0},
        {0, 0, 4, 4},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 5, 5, 5},
        {0, 5, 0, 0},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 6, 6, 6},
        {0, 0, 0, 6},
        {0, 0, 0, 0},

        {0, 0, 0, 0},
        {0, 7, 7, 7},
        {0, 0, 7, 0},
        {0, 0, 0, 0},
};

const float blockHeight = (tt_TOP - tt_BOTTOM) / VISABLE_ROWS;
const float blockWidth = (tt_RIGHT - tt_LEFT) / COLUMNS;

bool newBlock = true;

// Block class is the fundamental shape for making the Tetronimos for the Tetris game
class Block
{
private:
    int row;
    int column;
    float left;
    float right;
    float bottom;
    float top;
    int type;

public:
    // Takes the row and column from the matrix that represents the tetris grid
    // and creates the left, right, top and bottom coordinates
    Block() {}

    Block(int row, int column, int type)
    {
        Block::row = row;
        Block::column = column;
        Block::type = type;
        resetCoords();
    }
    void getCoords()
    {
        printf("width: %f \n", blockWidth);
        printf("LEFT: %f \n", left);
        printf("RIGHT: %f \n", right);
        printf("BOTTOM: %f \n", bottom);
        printf("TOP: %f \n", top);
    }
    int getRow()
    {
        return Block::row;
    }
    int getColumn()
    {
        return Block::column;
    }
    void setRowColumn(int row, int column)
    {
        boardLocations[Block::row][Block::column] = 0;
        Block::row = row;
        Block::column = column;
        boardLocations[Block::row][Block::column] = type;
        resetCoords();
    }
    void resetCoords()
    {
        left = tt_LEFT + (blockWidth * (column));
        right = tt_LEFT + (blockWidth * (column + 1));
        bottom = tt_BOTTOM + (blockHeight * (ROWS - row));
        top = tt_BOTTOM + (blockHeight * (ROWS - (row + 1)));
    }
    void display()
    {
        if (row < 2)
        {
            return;
        }
        //printf("%d, %d", row, column);
        glColor3f(1, 1, 0);
        glBegin(GL_QUADS);
        glVertex2f(left, bottom);
        glVertex2f(left, top);
        glVertex2f(right, top);
        glVertex2f(right, bottom);
        glEnd();

        //CHECK FOR COLLISIONS AND PERFORM MOVEMENT
    }
};

// Tetronimo class are the different shapes that can appear and be placed on the grid
// They are made up of Blocks
class Tetronimo
// Tetronimo is generated by choosing a random shape from the 7 selected
// check where the shape will fit in boardLocations and pass the row and column number to each new Block object - store in blocks
{
private:
    int shape[4][4];
    Block blocks[4]; //stores pointers to its corresponding blocks, each block has their own coordinates
    int type;

public:
    Tetronimo() {}
    void create()
    {
        type = rand() % 7;
        for (int y = 0; y < 4; y++)
        {
            for (int x = 0; x < 4; x++)
            {
                shape[y][x] = tetroShapes[(type * 4) + y][x];
            }
        }
    }
    void showShape()
    {
        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                std::cout << " " << shape[i][j] << " ";
            }
            std::cout << "\n";
        }
    }
    void spawnShape()
    {
        int row = -2;
        int column = 3;
        int index = 0;
        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
            {
                if (shape[i][j] == 1)
                {
                    Block block(row + i, column + j, type);
                    blocks[index] = block;
                    index++;
                }
            }
        }
    }

    bool checkLeft()
    {
        for (int i = 0; i < 4; i++)
        {
            int column = blocks[i].getColumn();
            if (column <= 0)
            {
                return false;
            }
        }
        return true;
    }

    bool checkRight()
    {
        for (int i = 0; i < 4; i++)
        {
            int column = blocks[i].getColumn();
            if (column >= 9)
            {
                return false;
            }
        }
        return true;
    }

    bool checkDown()
    {
        for (int i = 0; i < 4; i++)
        {
            int row = blocks[i].getRow();
            if (row >= 21)
            {
                return false;
            }
        }
        return true;
    }

    bool isBottom()
    {
        for (int i = 0; i < 4; i++)
        {
            int row = blocks[i].getRow();
            if (row == 21)
            {
                setLanded();
                return true;
            }
        }
        return false;
    }

    void setLanded()
    {
        //printf("Landed...\n");
        for (int i = 0; i < 4; i++)
        {
            int row = blocks[i].getRow();
            int column = blocks[i].getColumn();
            printf("Type: %d", type);
            landedBlockLocations[row][column] = type;
        }
    }

    // Check if there is a collision with another block from another tetronimo
    bool isCollision()
    {
        for (int i = 0; i < 4; i++)
        {
            int row = blocks[i].getRow();
            int column = blocks[i].getColumn();
            if (row != 21 and column != 9)
            {
                if (landedBlockLocations[row + 1][column] != 0)
                {
                    printf("Collision detected...\n");
                    setLanded();
                    return true;
                }
            }
        }
        //printf("\n");
        return false;
    }

    void moveLeft()
    {
        if (checkLeft() == true)
        {
            for (int i = 0; i < 4; i++)
            {
                // Check if a boundary is hit
                blocks[i].setRowColumn(blocks[i].getRow(), blocks[i].getColumn() - 1);
                blocks[i].display();
            }
        }
    }

    void moveRight()
    {
        if (checkRight() == true)
        {
            for (int i = 0; i < 4; i++)
            {
                // Check if a boundary is hit
                blocks[i].setRowColumn(blocks[i].getRow(), blocks[i].getColumn() + 1);
                blocks[i].display();
            }
        }
    }

    void fall()
    {
        if (checkDown() == true and elapsedTime > 0 and isCollision() == false)
        {
            for (int i = 0; i < 4; i++)
            {
                // Check if a boundary is hit
                int row = blocks[i].getRow();
                int column = blocks[i].getColumn();
                blocks[i].setRowColumn(row + 1, column);
                //printf("%d, %d\n", row, column);
                blocks[i].display();
            }
        }
        if (elapsedTime > 0)
        {
            elapsedTime--;
        }
    }

    void moveDownwards()
    {
        if (checkDown() == true and isCollision() == false)
        {
            for (int i = 0; i < 4; i++)
            {
                // Check if a boundary is hit
                int row = blocks[i].getRow();
                int column = blocks[i].getColumn();
                blocks[i].setRowColumn(row + 1, column);
                //printf("%d, %d\n", row, column);
                blocks[i].display();
            }
        }
        if (elapsedTime > 0)
        {
            elapsedTime--;
        }
    }

    // Display function calls the Block display function to show the tetromino
    void display()
    {
        for (int i = 0; i < 4; i++)
        {
            blocks[i].display();
        }
    }
};

Block blockLocations[ROWS][COLUMNS] = {};

char randomSelect()
{
    int randIndex = rand() % 7;
    return shapes[randIndex];
}

void printBoard()
{
    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLUMNS; j++)
        {
            printf("%d ", landedBlockLocations[i][j]);
        }
        printf("\n");
    }
}
// Creates the Tetris Grid where the game will be displaying the blocks
void drawGrid()
{
    // creates vertical lines
    for (int i = 0; i <= 10; i++)
    {
        glColor3f(1, 1, 1);
        glBegin(GL_LINES);
        glVertex2f(tt_LEFT + ((tt_RIGHT - tt_LEFT) / 10) * i, tt_BOTTOM);
        glVertex2f(tt_LEFT + ((tt_RIGHT - tt_LEFT) / 10) * i, tt_TOP);
        glEnd();
    }

    // creates horizontal lines
    for (int i = 0; i <= 20; i++)
    {
        glColor3f(1, 1, 1);
        glBegin(GL_LINES);
        glVertex2f(tt_LEFT, tt_BOTTOM + ((tt_TOP - tt_BOTTOM) / 20) * i);
        glVertex2f(tt_RIGHT, tt_BOTTOM + ((tt_TOP - tt_BOTTOM) / 20) * i);
        glEnd();
    }
}

void drawBlock()
{
    int row = 5;
    int column = 10;
    if (boardLocations[row][column] == 0)
    {
        Block block(row, column, 1);
        blockLocations[row][column] = block;
        boardLocations[row][column] = 1;
    }
    blockLocations[row][column].display();
}

void createTetromino()
{
    Tetronimo tetro;
    tetro.create();
    tetro.showShape();
}

void init()
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    // Defines 2d orthographic projection viewing
    // left, right, bottom, top
    gluOrtho2D(LEFT, RIGHT, BOTTOM, TOP);
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
}

Tetronimo allTetros[10];
int totalTetros = 0;

void playGame()
{
    while (newBlock)
    {
        //printBoard();
        printf("New Block made...\n");
        Tetronimo tetro;
        tetro.create();
        tetro.spawnShape();
        allTetros[totalTetros] = tetro;
        totalTetros++;
        newBlock = false;
    }

    for (int i = 0; i < totalTetros; i++)
    {
        if (i == totalTetros - 1)
        {
            allTetros[i].fall();
            if (allTetros[i].isBottom() or allTetros[i].isCollision())
            {
                newBlock = true;
            };
        }
        allTetros[i].display();
    }
}

// redraw callback
void display()
{
    //printf("Calling Display");
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1, 1, 1);
    drawGrid();
    playGame();
    glutSwapBuffers(); // swap the backbuffer with the front
    //printf("Display Done...\n");
}

void idle()
{
    //printf("Calling Idle \n");
    usleep(1000000);
    elapsedTime++;
    glutPostRedisplay();
}

void timer_func(int n)
{
    glutPostRedisplay();
    elapsedTime++;
    glutTimerFunc(1000, timer_func, 0);
}

void special(int key, int, int)
{
    // handle special keys
    switch (key)
    {
    case GLUT_KEY_LEFT:
        allTetros[totalTetros - 1].moveLeft();
        allTetros[totalTetros - 1].display();
        break;
    case GLUT_KEY_RIGHT:
        allTetros[totalTetros - 1].moveRight();
        allTetros[totalTetros - 1].display();
        break;
    case GLUT_KEY_UP:
        // Rotate shape
        break;
    case GLUT_KEY_DOWN:
        allTetros[totalTetros - 1].moveDownwards();
        allTetros[totalTetros - 1].display();
        break;
    }

    //elapsedTime++;
    glutPostRedisplay();
}

int main(int argc, char *argv[])
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);
    glutInitWindowSize(700, 700);
    glutInitWindowPosition(50, 50);
    glutCreateWindow("Tetris");
    init();
    srand(time(0));
    glutDisplayFunc(display);
    //glutIdleFunc(idle);
    glutTimerFunc(1000, timer_func, 0);

    // handlers for keyboard input
    //glutKeyboardFunc(keyboard);
    glutSpecialFunc(special);

    glutMainLoop();

    return 0;
}